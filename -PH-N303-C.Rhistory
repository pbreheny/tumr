data_ind <- data |>
dplyr::filter(!is.na(.data[[measure]]))
data_sum <- summary_data |>
dplyr::filter(!is.na(summary_data$MedianVolume))
ggplot2::ggplot() +
ggplot2::geom_line(
data = data_ind,
ggplot2::aes(
x = .data[[time]],
y = .data[[measure]],
group = .data[[id]],
color = .data[[group]]
),
alpha = 0.5
) +
ggplot2::geom_line(
data = data_sum,
ggplot2::aes(
x = .data[[time]],
y = .data[["MedianVolume"]],
color = .data[[group]]
),
linewidth = 1.2
) +
ggplot2::labs(
y = "Volume",
title = "Volume over Time"
)
#print(summary_data)
#print(data)
}
plot_median(
data = melanoma1,
group = "Treatment",
time = "Day",
measure = "Volume",
id = "ID"
)
plot_median(
data = breast,
group = "Treatment",
time = "Week",
measure = "Volume",
id = "ID"
)
data(melanoma1)
plot_median(
data = melanoma1,
group = "Treatment",
time = "Day",
measure = "Volume",
id = "ID"
)
devtools::check()
devtools::check()
devtools::load_all(".")
plot_median(
data = breast,
group = "Treatment",
time = "Week",
measure = "Volume",
id = "ID"
)
data(melanoma1)
plot_median(
data = melanoma1,
group = "Treatment",
time = "Day",
measure = "Volume",
id = "ID"
)
data(breast)
v1 <- c(1, 3, 5, 9)
v2 <- c(16, NA, NA, 54)
approxfun(v1, v2)
approxfun(v1, v2)
v3 <- approxfun(v1, v2)
View(v3)
?approxfun
approxfun(v1, v2, method = "linear")
process_data <- function(time, volume) {
if (length(time) != length(volume)) {
stop("Time and volume vectors must be of the same length.")
}
if (all(is.na(volume))) {
stop("Must have at least 1 non-missing value")
}
# Track missing values before modification
missing_vector <- ifelse(is.na(volume), 0, 1)
# Interpolate internal NAs using approxfun
interp_fun <- approxfun(time[!is.na(volume)], volume[!is.na(volume)], rule = 1)
volume_interp <- volume
na_indices <- which(is.na(volume))
if (length(na_indices) > 0) {
# Interpolate embedded NAs
for (i in na_indices) {
if (i < length(volume) && any(!is.na(volume[(i + 1):length(volume)]))) {
volume_interp[i] <- interp_fun(time[i])
}
}
# Fill trailing NAs by carrying forward the last non-NA value
last_val_index <- max(which(!is.na(volume)))
if (last_val_index < length(volume)) {
volume_interp[(last_val_index + 1):length(volume)] <- volume[last_val_index]
}
}
return(list(
data_no_missing_values = volume_interp,
missing_vector = missing_vector
))
}
v1<- c(1, 3, 5, 7, 10)
v2 <- c(15, NA, NA, 67, NA)
process_data(v1, v2)
process_data <- function(time, volume) {
if (length(time) != length(volume)) {
stop("Time and volume vectors must be the same length.")
}
if (all(is.na(volume))) {
stop("Must have at least one non-missing value.")
}
# Identify NA positions
na_indices <- which(is.na(volume))
# Copy volume for modification
volume_clean <- volume
# Find last non-NA index
last_val_index <- max(which(!is.na(volume)))
# Step 1: Interpolate embedded NAs using approxfun
if (length(na_indices) > 0) {
interp_fun <- approxfun(
x = time[!is.na(volume)],
y = volume[!is.na(volume)],
rule = 1  # no extrapolation
)
for (i in na_indices) {
# Interpolate only if not a trailing NA
if (i <= last_val_index) {
volume_clean[i] <- interp_fun(time[i])
}
}
# Step 2: Fill trailing NAs by carrying forward last value
if (last_val_index < length(volume)) {
volume_clean[(last_val_index + 1):length(volume)] <- volume[last_val_index]
}
}
# Step 3: Create missing_vector (0 only for trailing NAs)
missing_vector <- rep(1, length(volume))
if (last_val_index < length(volume)) {
missing_vector[(last_val_index + 1):length(volume)] <- 0
}
return(list(
data_no_missing_values = volume_clean,
missing_vector = missing_vector
))
}
process_data(v1, v2)
process_data <- function(time, measure) {
if (length(time) != length(measure)) {
stop("Time and measure vectors must be the same length.")
}
if (all(is.na(measure))) {
stop("Must have at least one non-missing value.")
}
# Identify NA positions
na_indices <- which(is.na(measure))
# Copy for cleaned output
measure_clean <- measure
# Find last non-NA index
last_val_index <- max(which(!is.na(measure)))
# Step 1: Interpolate embedded NAs
if (length(na_indices) > 0) {
interp_fun <- approxfun(
x = time[!is.na(measure)],
y = measure[!is.na(measure)],
rule = 1  # no extrapolation
)
for (i in na_indices) {
if (i <= last_val_index) {
# Interpolate only embedded NAs
measure_clean[i] <- interp_fun(time[i])
}
}
# Step 2: Fill trailing NAs with last non-NA value
if (last_val_index < length(measure)) {
measure_clean[(last_val_index + 1):length(measure)] <- measure[last_val_index]
}
}
# Step 3: Construct missing vector (0 only for trailing fills)
missing_vector <- rep(1, length(measure))
if (last_val_index < length(measure)) {
missing_vector[(last_val_index + 1):length(measure)] <- 0
}
return(list(
data_no_missing_values = measure_clean,
missing_vector = missing_vector
))
}
v1<- c(1, 3, 5, 7, 10)
v2 <- c(15, NA, NA, 67, NA)
process_data(v1, v2)
process_data <- function(x){
y <- x
if (length(which(is.na(x))) == 0) {
all_na_at_end <- TRUE
}
all_na_at_end <- all(which(is.na(x)) == seq(from = length(x) - length(which(is.na(x))) + 1, to = length(x)))
#
#    if(all_na_at_end != TRUE){
#      stop("Cannot have embedded missing values")
#    }
if(all(is.na(x))){
stop("Must have at least 1 non-missing value")
}
last_val_index <- max(which(!is.na(x)))
last_val <- x[last_val_index]
if (last_val_index < length(x)) {
x[(last_val_index + 1):length(x)] <- last_val
}
if(length(which(is.na(y))) == 0){
y[(1:length(y))] <- 1
} else {
y[(last_val_index + 1):length(x)] <- 0
y[(1:last_val_index)] <- 1
}
return(list(
data_no_missing_values = x,
missing_vector = y
))
}
process_data(v2)
process_data <- function(time, measure) {
if (length(time) != length(measure)) {
stop("Time and measure vectors must be the same length.")
}
if (all(is.na(measure))) {
stop("Must have at least one non-missing value.")
}
# Identify NA positions
na_indices <- which(is.na(measure))
# Copy for cleaned output
measure_clean <- measure
# Find last non-NA index
last_val_index <- max(which(!is.na(measure)))
# Step 1: Interpolate embedded NAs
if (length(na_indices) > 0) {
interp_fun <- approxfun(
x = time[!is.na(measure)],
y = measure[!is.na(measure)],
rule = 1  # no extrapolation
)
for (i in na_indices) {
if (i <= last_val_index) {
# Interpolate only embedded NAs
measure_clean[i] <- interp_fun(time[i])
}
}
# Step 2: Fill trailing NAs with last non-NA value
if (last_val_index < length(measure)) {
measure_clean[(last_val_index + 1):length(measure)] <- measure[last_val_index]
}
}
# Step 3: Construct missing vector (0 only for trailing fills)
missing_vector <- rep(1, length(measure))
if (last_val_index < length(measure)) {
missing_vector[(last_val_index + 1):length(measure)] <- 0
}
return(list(
data_no_missing_values = measure_clean,
missing_vector = missing_vector
))
}
plot_median <- function(data, group, time, measure, id) {
#adding in missing rows
data <- data |>
tidyr::complete(.data[[id]], .data[[time]]) |>
dplyr::group_by(.data[[id]]) |>
tidyr::fill(.data[[group]], .direction = "down")
# Compute survival-adjusted medians using process_data()
processed_data <- data |>
dplyr::group_by(.data[[id]]) |>
dplyr::group_modify(~ {
processed <- process_data(.x[[time]], .x[[measure]])
surv_list <- base::mapply(
FUN = function(time, event) survival::Surv(time, event),
time = processed$data_no_missing_values,
event = processed$missing_vector,
SIMPLIFY = FALSE
)
tibble::tibble(
!!id := .x[[id]],
!!group := .x[[group]],
!!time := .x[[time]],
SurvObj = surv_list
)
}) |>
dplyr::ungroup()
# Compute survival-adjusted medians per group + time
summary_data <- processed_data |>
dplyr::group_by(.data[[time]], .data[[group]]) |>
dplyr::group_modify(~ {
surv_vec <- base::do.call("c", .x$SurvObj)
surv_fit <- survival::survfit(surv_vec ~ 1)
fit_table <- summary(surv_fit)$table
median_volume <- fit_table["median"]
lower_ci <- fit_table["0.95LCL"]
upper_ci <- fit_table["0.95UCL"]
tibble::tibble(
MedianVolume = median_volume,
CI_Lower = lower_ci,
CI_Upper = upper_ci
)
}) |>
dplyr::ungroup()
# Plot
data_ind <- data |>
dplyr::filter(!is.na(.data[[measure]]))
data_sum <- summary_data |>
dplyr::filter(!is.na(summary_data$MedianVolume))
ggplot2::ggplot() +
ggplot2::geom_line(
data = data_ind,
ggplot2::aes(
x = .data[[time]],
y = .data[[measure]],
group = .data[[id]],
color = .data[[group]]
),
alpha = 0.5
) +
ggplot2::geom_line(
data = data_sum,
ggplot2::aes(
x = .data[[time]],
y = .data[["MedianVolume"]],
color = .data[[group]]
),
linewidth = 1.2
) +
ggplot2::labs(
y = "Volume",
title = "Volume over Time"
)
#print(summary_data)
#print(data)
}
plot_median(
data = breast,
group = "Treatment",
time = "Week",
measure = "Volume",
id = "ID"
)
data(melanoma1)
plot_median(
data = melanoma1,
group = "Treatment",
time = "Day",
measure = "Volume",
id = "ID"
)
plot_median(
data = melanoma2,
group = "Treatment",
time = "Day",
measure = "Volume",
id = "ID"
)
@export
process_data <- function(time, measure) {
# if (length(time) != length(measure)) {
#   stop("Time and measure vectors must be the same length.")
# }
if (all(is.na(measure))) {
stop("Must have at least one non-missing value.")
}
# Identify NA positions
na_indices <- which(is.na(measure))
# Copy for cleaned output
measure_clean <- measure
# Find last non-NA index
last_val_index <- max(which(!is.na(measure)))
# Step 1: Interpolate embedded NAs
if (length(na_indices) > 0) {
interp_fun <- approxfun(
x = time[!is.na(measure)],
y = measure[!is.na(measure)],
rule = 1  # no extrapolation
)
for (i in na_indices) {
if (i <= last_val_index) {
# Interpolate only embedded NAs
measure_clean[i] <- interp_fun(time[i])
}
}
# Step 2: Fill trailing NAs with last non-NA value
if (last_val_index < length(measure)) {
measure_clean[(last_val_index + 1):length(measure)] <- measure[last_val_index]
}
}
# Step 3: Construct missing vector (0 only for trailing fills)
missing_vector <- rep(1, length(measure))
if (last_val_index < length(measure)) {
missing_vector[(last_val_index + 1):length(measure)] <- 0
}
return(list(
data_no_missing_values = measure_clean,
missing_vector = missing_vector
))
}
data(breast)
plot_median(
data = breast,
group = "Treatment",
time = "Week",
measure = "Volume",
id = "ID"
)
data(melanoma1)
plot_median(
data = melanoma2,
group = "Treatment",
time = "Day",
measure = "Volume",
id = "ID"
)
data(prostate)
View(prostate)
plot_median(
data = prostate,
group = "Genotype",
time = "Age",
measure = "BLI",
id = "ID"
)
process_data <- function(time, measure) {
if (all(is.na(measure))) {
stop("Must have at least one non-missing value.")
}
# Identify NA positions
na_indices <- which(is.na(measure))
# Copy for cleaned output
measure_clean <- measure
# Find last non-NA index
last_val_index <- max(which(!is.na(measure)))
# Step 1: Interpolate embedded NAs
if (length(na_indices) > 0) {
interp_fun <- approxfun(
x = time[!is.na(measure)],
y = measure[!is.na(measure)],
rule = 1  # no extrapolation
)
# for (i in na_indices) {
#   if (i <= last_val_index) {
#     # Interpolate only embedded NAs
#     measure_clean[i] <- interp_fun(time[i])
#   }
# }
# Step 2: Fill trailing NAs with last non-NA value
if (last_val_index < length(measure)) {
measure_clean[(last_val_index + 1):length(measure)] <- measure[last_val_index]
}
}
# Step 3: Construct missing vector (0 only for trailing fills)
missing_vector <- rep(1, length(measure))
if (last_val_index < length(measure)) {
missing_vector[(last_val_index + 1):length(measure)] <- 0
}
return(list(
data_no_missing_values = measure_clean,
missing_vector = missing_vector
))
}
process_data(v1, v2)
process_data <- function(time, measure) {
if (all(is.na(measure))) {
stop("Must have at least one non-missing value.")
}
# Identify NA positions
na_indices <- which(is.na(measure))
# Copy for cleaned output
measure_clean <- measure
# Find last non-NA index
last_val_index <- max(which(!is.na(measure)))
# Step 1: Interpolate embedded NAs
if (length(na_indices) > 0) {
interp_fun <- approxfun(
x = time[!is.na(measure)],
y = measure[!is.na(measure)],
rule = 1  # no extrapolation
)
for (i in na_indices) {
if (i <= last_val_index) {
# Interpolate only embedded NAs
measure_clean[i] <- interp_fun(time[i])
}
}
# Step 2: Fill trailing NAs with last non-NA value
if (last_val_index < length(measure)) {
measure_clean[(last_val_index + 1):length(measure)] <- measure[last_val_index]
}
}
# Step 3: Construct missing vector (0 only for trailing fills)
missing_vector <- rep(1, length(measure))
if (last_val_index < length(measure)) {
missing_vector[(last_val_index + 1):length(measure)] <- 0
}
return(list(
data_no_missing_values = measure_clean,
missing_vector = missing_vector
))
}
process_data(v1, v2)
